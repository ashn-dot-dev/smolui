namespace smolui;
import "c";
import "std";

import "raylib";

import "microui.sunder";

extern func mu_context_new() *mu_Context;
extern func mu_context_del(ctx: *mu_Context) void;

extern func setup_font(ctx: *mu_Context, font: *Font) void;
extern func handle_input(ctx: *mu_Context) void;
extern func render(ctx: *mu_Context) void;

alias rect = mu_Rect;

var RES_ACTIVE = (:sint)MU_RES_ACTIVE;
var RES_SUBMIT = (:sint)MU_RES_SUBMIT;
var RES_CHANGE = (:sint)MU_RES_CHANGE;

var ICON_CLOSE      = (:sint)MU_ICON_CLOSE;
var ICON_CHECK      = (:sint)MU_ICON_CHECK;
var ICON_COLLAPSED  = (:sint)MU_ICON_COLLAPSED;
var ICON_EXPANDED   = (:sint)MU_ICON_EXPANDED;
var ICON_MAX        = (:sint)MU_ICON_MAX;

var OPT_ALIGNCENTER = (:sint)MU_OPT_ALIGNCENTER;
var OPT_ALIGNRIGHT  = (:sint)MU_OPT_ALIGNRIGHT;
var OPT_NOINTERACT  = (:sint)MU_OPT_NOINTERACT;
var OPT_NOFRAME     = (:sint)MU_OPT_NOFRAME;
var OPT_NORESIZE    = (:sint)MU_OPT_NORESIZE;
var OPT_NOSCROLL    = (:sint)MU_OPT_NOSCROLL;
var OPT_NOCLOSE     = (:sint)MU_OPT_NOCLOSE;
var OPT_NOTITLE     = (:sint)MU_OPT_NOTITLE;
var OPT_HOLDFOCUS   = (:sint)MU_OPT_HOLDFOCUS;
var OPT_AUTOSIZE    = (:sint)MU_OPT_AUTOSIZE;
var OPT_POPUP       = (:sint)MU_OPT_POPUP;
var OPT_CLOSED      = (:sint)MU_OPT_CLOSED;
var OPT_EXPANDED    = (:sint)MU_OPT_EXPANDED;

struct context {
    var mu_ctx: *mu_Context;

    # Init a UI context with provided font.
    # Providing a NULL font pointer wll use the default raylib font.
    func init(font: *Font) context {
        var ctx = mu_context_new();
        mu_init(ctx);
        setup_font(ctx, font);
        return (:context){.mu_ctx = ctx};
    }

    func fini(self: *context) void {
        mu_context_del(self.*.mu_ctx);
    }

    func handle_input(self: *context) void {
        smolui::handle_input(self.*.mu_ctx);
    }

    func begin(self: *context) void {
        mu_begin(self.*.mu_ctx);
    }

    func end(self: *context) void {
        mu_end(self.*.mu_ctx);
    }

    func text(self: *context, text: []byte) void {
        var s = std::string::init_from_str(text);
        defer s.fini();
        mu_text(self.*.mu_ctx, s.cstr());
    }

    func label(self: *context, text: []byte) void {
        var s = std::string::init_from_str(text);
        defer s.fini();
        mu_label(self.*.mu_ctx, s.cstr());
    }

    func button(self: *context, text: []byte) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_button(self.*.mu_ctx, s.cstr()) != 0;
    }

    func button_ex(self: *context, text: []byte, icon: sint, opt: sint) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_button_ex(self.*.mu_ctx, s.cstr(), icon, opt) != 0;
    }

    func checkbox(self: *context, text: []byte, state: *bool) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        var int = (:sint)*state;
        var res = mu_checkbox(self.*.mu_ctx, s.cstr(), &int) != 0;
        *state = (:bool)int;
        return res;
    }

    func textbox(self: *context, text: *std::string) bool {
        return self.*.textbox_ex(text, 0) != 0;
    }

    func textbox_ex(self: *context, text: *std::string, opt: sint) sint {
        # The address of the buffer may change during resize, so we use the
        # address of the std::string as the ID rather than the hashed value of
        # the buffer address that mu_textbox_ex would normally use.
        var id = (:mu_Id)(:usize)text;
        var r = mu_layout_next(self.*.mu_ctx);
        let INPUT_TEXT_SIZE = 32u;
        text.*.reserve(text.*.count() + INPUT_TEXT_SIZE);
        var res = mu_textbox_raw(self.*.mu_ctx, text.*.start(), (:sint)(text.*.capacity() + countof("\0")), id, r, opt);
        text.*.resize(std::cstr::count(text.*.cstr()));
        return res;
    }

    func slider(self: *context, value: *float, lo: float, hi: float) bool {
        return mu_slider(self.*.mu_ctx, value, lo, hi) != 0;
    }

    func number(self: *context, value: *float, step: float) bool {
        return mu_number(self.*.mu_ctx, value, step) != 0;
    }

    func header(self: *context, text: []byte) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_header(self.*.mu_ctx, s.cstr()) != 0;
    }

    func header_ex(self: *context, text: []byte, opt: sint) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_header_ex(self.*.mu_ctx, s.cstr(), opt) != 0;
    }

    func begin_treenode(self: *context, text: []byte) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_begin_treenode(self.*.mu_ctx, s.cstr()) != 0;
    }

    func begin_treenode_ex(self: *context, text: []byte, opt: sint) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_begin_treenode_ex(self.*.mu_ctx, s.cstr(), opt) != 0;
    }

    func end_treenode(self: *context) void {
        mu_end_treenode(self.*.mu_ctx);
    }

    func begin_window(self: *context, title: []byte, rect: rect) bool {
        var s = std::string::init_from_str(title);
        defer s.fini();
        return mu_begin_window(self.*.mu_ctx, s.cstr(), rect) != 0;
    }

    func begin_window_ex(self: *context, title: []byte, rect: rect, opt: sint) bool {
        var s = std::string::init_from_str(title);
        defer s.fini();
        return mu_begin_window_ex(self.*.mu_ctx, s.cstr(), rect, opt) != 0;
    }

    func end_window(self: *context) void {
        mu_end_window(self.*.mu_ctx);
    }

    func open_popup(self: *context, name: []byte) void {
        var s = std::string::init_from_str(name);
        defer s.fini();
        mu_open_popup(self.*.mu_ctx, s.cstr());
    }

    func begin_popup(self: *context, name: []byte) bool {
        var s = std::string::init_from_str(name);
        defer s.fini();
        return mu_begin_popup(self.*.mu_ctx, s.cstr()) != 0;
    }

    func end_popup(self: *context) void {
        mu_end_popup(self.*.mu_ctx);
    }

    func begin_panel(self: *context, name: []byte) void {
        var s = std::string::init_from_str(name);
        defer s.fini();
        mu_begin_panel(self.*.mu_ctx, s.cstr());
    }

    func begin_panel_ex(self: *context, name: []byte, opt: sint) void {
        var s = std::string::init_from_str(name);
        defer s.fini();
        mu_begin_panel_ex(self.*.mu_ctx, s.cstr(), opt);
    }

    func end_panel(self: *context) void {
        mu_end_panel(self.*.mu_ctx);
    }

    func render(self: *context) void {
        smolui::render(self.*.mu_ctx);
    }
}
