namespace smol;
import "c";
import "std";

import "raylib";

import "microui.sunder";

extern func setup_font(ctx: *mu_Context, font: *Font) void;
extern func handle_input(ctx: *mu_Context) void;
extern func render(ctx: *mu_Context) void;

alias rect = mu_Rect;

let RES_ACTIVE = MU_RES_ACTIVE;
let RES_SUBMIT = MU_RES_SUBMIT;
let RES_CHANGE = MU_RES_CHANGE;

let ICON_CLOSE      = MU_ICON_CLOSE;
let ICON_CHECK      = MU_ICON_CHECK;
let ICON_COLLAPSED  = MU_ICON_COLLAPSED;
let ICON_EXPANDED   = MU_ICON_EXPANDED;

let OPT_ALIGNCENTER = MU_OPT_ALIGNCENTER;
let OPT_ALIGNRIGHT  = MU_OPT_ALIGNRIGHT;
let OPT_NOINTERACT  = MU_OPT_NOINTERACT;
let OPT_NOFRAME     = MU_OPT_NOFRAME;
let OPT_NORESIZE    = MU_OPT_NORESIZE;
let OPT_NOSCROLL    = MU_OPT_NOSCROLL;
let OPT_NOCLOSE     = MU_OPT_NOCLOSE;
let OPT_NOTITLE     = MU_OPT_NOTITLE;
let OPT_HOLDFOCUS   = MU_OPT_HOLDFOCUS;
let OPT_AUTOSIZE    = MU_OPT_AUTOSIZE;
let OPT_POPUP       = MU_OPT_POPUP;
let OPT_CLOSED      = MU_OPT_CLOSED;
let OPT_EXPANDED    = MU_OPT_EXPANDED;

struct ui {
    var context: *mu_Context;

    func init(ctx: *mu_Context) ui {
        return (:ui){.context = ctx};
    }

    func handle_input(self: *ui) void {
        smol::handle_input(self.*.context);
    }

    func begin(self: *ui) void {
        mu_begin(self.*.context);
    }

    func end(self: *ui) void {
        mu_end(self.*.context);
    }

    func layout_row(self: *ui, widths: []sint, height: sint) void {
        mu_layout_row(self.*.context, (:sint)countof(widths), startof(widths), height);
    }

    func text(self: *ui, text: []byte) void {
        var s = std::string::init_from_str(text);
        defer s.fini();
        mu_text(self.*.context, s.cstr());
    }

    func label(self: *ui, text: []byte) void {
        var s = std::string::init_from_str(text);
        defer s.fini();
        mu_label(self.*.context, s.cstr());
    }

    func button(self: *ui, text: []byte) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_button(self.*.context, s.cstr()) != 0;
    }

    func button_ex(self: *ui, text: []byte, icon: sint, opt: sint) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_button_ex(self.*.context, s.cstr(), icon, opt) != 0;
    }

    func checkbox(self: *ui, text: []byte, state: *bool) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        var int = (:sint)*state;
        var res = mu_checkbox(self.*.context, s.cstr(), &int) != 0;
        *state = (:bool)int;
        return res;
    }

    func textbox(self: *ui, text: *std::string) bool {
        return self.*.textbox_ex(text, 0) != 0;
    }

    func textbox_ex(self: *ui, text: *std::string, opt: sint) sint {
        # The address of the buffer may change during resize, so we use the
        # address of the std::string as the ID rather than the hashed value of
        # the buffer address that mu_textbox_ex would normally use.
        var id = (:mu_Id)(:usize)text;
        var r = mu_layout_next(self.*.context);
        let INPUT_TEXT_SIZE = 32u;
        text.*.reserve(text.*.count() + INPUT_TEXT_SIZE);
        var res = mu_textbox_raw(self.*.context, text.*.start(), (:sint)(text.*.capacity() + countof("\0")), id, r, opt);
        text.*.resize(std::cstr::count(text.*.cstr()));
        return res;
    }

    func slider(self: *ui, value: *float, lo: float, hi: float) bool {
        return mu_slider(self.*.context, value, lo, hi) != 0;
    }

    func slider_ex(self: *ui, value: *float, lo: float, hi: float, step: float, fmt: *char, opt: sint) bool {
        return mu_slider_ex(self.*.context, value, lo, hi, step, fmt, opt) != 0;
    }

    func number(self: *ui, value: *float, step: float) bool {
        return mu_number(self.*.context, value, step) != 0;
    }

    func header(self: *ui, text: []byte) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_header(self.*.context, s.cstr()) != 0;
    }

    func header_ex(self: *ui, text: []byte, opt: sint) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_header_ex(self.*.context, s.cstr(), opt) != 0;
    }

    func begin_treenode(self: *ui, text: []byte) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_begin_treenode(self.*.context, s.cstr()) != 0;
    }

    func begin_treenode_ex(self: *ui, text: []byte, opt: sint) bool {
        var s = std::string::init_from_str(text);
        defer s.fini();
        return mu_begin_treenode_ex(self.*.context, s.cstr(), opt) != 0;
    }

    func end_treenode(self: *ui) void {
        mu_end_treenode(self.*.context);
    }

    func begin_window(self: *ui, title: []byte, rect: rect) bool {
        var s = std::string::init_from_str(title);
        defer s.fini();
        return mu_begin_window(self.*.context, s.cstr(), rect) != 0;
    }

    func begin_window_ex(self: *ui, title: []byte, rect: rect, opt: sint) bool {
        var s = std::string::init_from_str(title);
        defer s.fini();
        return mu_begin_window_ex(self.*.context, s.cstr(), rect, opt) != 0;
    }

    func end_window(self: *ui) void {
        mu_end_window(self.*.context);
    }

    func open_popup(self: *ui, name: []byte) void {
        var s = std::string::init_from_str(name);
        defer s.fini();
        mu_open_popup(self.*.context, s.cstr());
    }

    func begin_popup(self: *ui, name: []byte) bool {
        var s = std::string::init_from_str(name);
        defer s.fini();
        return mu_begin_popup(self.*.context, s.cstr()) != 0;
    }

    func end_popup(self: *ui) void {
        mu_end_popup(self.*.context);
    }

    func begin_panel(self: *ui, name: []byte) void {
        var s = std::string::init_from_str(name);
        defer s.fini();
        mu_begin_panel(self.*.context, s.cstr());
    }

    func begin_panel_ex(self: *ui, name: []byte, opt: sint) void {
        var s = std::string::init_from_str(name);
        defer s.fini();
        mu_begin_panel_ex(self.*.context, s.cstr(), opt);
    }

    func end_panel(self: *ui) void {
        mu_end_panel(self.*.context);
    }

    func render(self: *ui) void {
        smol::render(self.*.context);
    }
}
